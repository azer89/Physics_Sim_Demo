/*
-----------------------------------------------------------------------------
Filename:    AZBullet.cpp
-----------------------------------------------------------------------------


This source file is generated by the
   ___                   _              __    __ _                  _ 
  /___\__ _ _ __ ___    /_\  _ __  _ __/ / /\ \ (_)______ _ _ __ __| |
 //  // _` | '__/ _ \  //_\\| '_ \| '_ \ \/  \/ / |_  / _` | '__/ _` |
/ \_// (_| | | |  __/ /  _  \ |_) | |_) \  /\  /| |/ / (_| | | | (_| |
\___/ \__, |_|  \___| \_/ \_/ .__/| .__/ \/  \/ |_/___\__,_|_|  \__,_|
      |___/                 |_|   |_|                                 
      Ogre 1.7.x Application Wizard for VC9 (July 2011)
      http://code.google.com/p/ogreappwizards/
-----------------------------------------------------------------------------
*/
#include "Stdafx.h"
#include "AZBullet.h"
#include "ObstacleForFun.h"
#include "TerrainManager.h"
#include "Vehicle.h"

#include "Shapes/OgreBulletCollisionsBoxShape.h"
#include "Shapes/OgreBulletCollisionsCompoundShape.h"
#include "Shapes/OgreBulletCollisionsTerrainShape.h"

#include "OgreBulletDynamicsWorld.h"
#include "OgreBulletDynamicsRigidBody.h"
#include "Debug/OgreBulletCollisionsDebugDrawer.h"

#include "Constraints/OgreBulletDynamicsRaycastVehicle.h"

#if !(OGRE_VERSION <  ((1 << 16) | (3 << 8) | 0))
using namespace OIS;
#endif 

using namespace Ogre;
using namespace OgreBulletCollisions;
using namespace OgreBulletDynamics;

/*
static float	gMaxEngineForce = 3000.f;

static float	gSteeringIncrement = 0.04f;
static float	gSteeringClamp = 0.8f;

static float	gWheelRadius = 0.5f;
static float	gWheelWidth = 0.4f;

static float	gWheelFriction = 1e30f;//1000;//1e30f;
static float	gSuspensionStiffness = 20.f;
static float	gSuspensionDamping = 2.3f;
static float	gSuspensionCompression = 4.4f;

static float	gRollInfluence = 
//0.1f;
1.0f;
static float   gSuspensionRestLength = 0.6;
static float   gMaxSuspensionTravelCm = 500.0;
static float   gFrictionSlip = 10.5;
*/

static const Ogre::Vector3    CameraStart            = Ogre::Vector3(0, 25, 0);
// -------------------------------------------------------------------------
//static const Ogre::Vector3   CarPosition             = Ogre::Vector3(15, 3,-15);

// #define CUBE_HALF_EXTENTS 1

//-------------------------------------------------------------------------------------
AZBullet::~AZBullet(void)
{
}

//-------------------------------------------------------------------------------------

void AZBullet::createScene(void)
{	
	/*
    Ogre::Entity* mEntity = mSceneMgr->createEntity("Head", "wheel.mesh");

    Ogre::SceneNode* mNode = mSceneMgr->getRootSceneNode()->createChildSceneNode();
    mNode->attachObject(mEntity);
	mNode->scale(10.0f, 10.0f, 10.0f);

    // Set ambient light
    mSceneMgr->setAmbientLight(Ogre::ColourValue(0.5, 0.5, 0.5));

    // Create a light
    Ogre::Light* l = mSceneMgr->createLight("MainLight");
    l->setPosition(20,80,50);
	*/

	this->bulletInit();
}

// -------------------------------------------------------------------------
void AZBullet::bulletInit()
{	
	mBulletCamera = mCamera;		// OgreBulletListener's camera
	mBulletWindow = mWindow;		// OgreBulletListener's window
	mBulletRoot = mRoot;			// OgreBulletListener's root
	mBulletSceneMgr = mSceneMgr;	// OgreBulletListener's scene manager

	mBulletCameraMove = 1;

	Viewport *vp = this->mCamera->getViewport();
	vp->setBackgroundColour(ColourValue(0,0,0));

	// add lights
	setBulletBasicLight();

	// Start Bullet
	initWorld();

	// Create a terrain
	TerrainManager* tManager = new TerrainManager();
	tManager->createTerrain(mSceneMgr, mBulletWorld, mBodies, mShapes);

	// create a vehicle
	Vehicle* vehicle = new Vehicle();
	vehicle->createVehicle(this->mSceneMgr, this->mBulletWorld, this->mNumEntitiesInstanced, tManager->terrain_Shift);

	// Alter the camera aspect ratio to match the viewport
	mCamera->setAspectRatio(Real(vp->getActualWidth()) / Real(vp->getActualHeight()));
	mCamera->setPosition(CameraStart + tManager->terrain_Shift);
	mCamera->lookAt(vehicle->CarPosition + tManager->terrain_Shift);

	// create the obstacle
	ObstacleForFun* obs = new ObstacleForFun();
	obs->createObstacle(this, tManager->terrain_Shift);

	
	/*
	// reset
	for (int i = 0; i < 4; i++)
	{
		mWheelsEngine[i] = 0;
		mWheelsSteerable[i] = 0;
	}

	mWheelsEngineCount = 2;
	mWheelsEngine[0] = 0;
	mWheelsEngine[1] = 1;
	mWheelsEngine[2] = 2;
	mWheelsEngine[3] = 3;

	mWheelsSteerableCount = 2;
	mWheelsSteerable[0] = 0;
	mWheelsSteerable[1] = 1;

	mWheelEngineStyle = 0;
	mWheelSteeringStyle = 0;

	mSteeringLeft = false;
	mSteeringRight = false;

	mEngineForce = 0;
	mSteering = 0;

	const Ogre::Vector3 chassisShift(0, 1.0, 0);
	float connectionHeight = 0.7f;

	mChassis = mSceneMgr->createEntity(
		"chassis" + StringConverter::toString(mNumEntitiesInstanced++),
		"chassis.mesh");

	SceneNode *node = mSceneMgr->getRootSceneNode ()->createChildSceneNode ();

	SceneNode *chassisnode = node->createChildSceneNode ();
	chassisnode->attachObject (mChassis);
	chassisnode->setPosition (chassisShift);

	mChassis->setCastShadows(true);

	CompoundCollisionShape* compound = new CompoundCollisionShape();

	BoxCollisionShape* chassisShape = new BoxCollisionShape(Ogre::Vector3(1.f,0.75f,2.1f));
	compound->addChildShape(chassisShape, chassisShift); 

	mCarChassis = new WheeledRigidBody("carChassis", mBulletWorld);

	mCarChassis->setShape (node, 
		compound, 
		0.6, //restitution
		0.6, //friction
		800, //bodyMass
		CarPosition +  tManager->terrain_Shift , 
		Quaternion::IDENTITY);
	mCarChassis->setDamping(0.2, 0.2);

	mCarChassis->disableDeactivation ();
	mTuning = new VehicleTuning(
		gSuspensionStiffness,
		gSuspensionCompression,
		gSuspensionDamping,
		gMaxSuspensionTravelCm,
		gFrictionSlip);

	mVehicleRayCaster = new VehicleRayCaster(mBulletWorld);
	mVehicle = new RaycastVehicle(mCarChassis, mTuning, mVehicleRayCaster);

	int rightIndex = 0;
	int upIndex = 1;
	int forwardIndex = 2;

	mVehicle->setCoordinateSystem(rightIndex, upIndex, forwardIndex);

	Ogre::Vector3 wheelDirectionCS0(0,-1,0);
	Ogre::Vector3 wheelAxleCS(-1,0,0);

	for (size_t i = 0; i < 4; i++)
	{
		mWheels[i] = mSceneMgr->createEntity(
			"wheel" + StringConverter::toString(mNumEntitiesInstanced++),
			"wheel.mesh");

		mWheels[i]->setQueryFlags (GEOMETRY_QUERY_MASK);

		mWheels[i]->setCastShadows(true);

		mWheelNodes[i] = mSceneMgr->getRootSceneNode ()->createChildSceneNode ();
		mWheelNodes[i]->attachObject (mWheels[i]);

	}

	bool isFrontWheel = true;

	Ogre::Vector3 connectionPointCS0 (
		CUBE_HALF_EXTENTS-(0.3*gWheelWidth),
		connectionHeight,
		2*CUBE_HALF_EXTENTS-gWheelRadius);


	mVehicle->addWheel(
		mWheelNodes[0],
		connectionPointCS0,
		wheelDirectionCS0,
		wheelAxleCS,
		gSuspensionRestLength,
		gWheelRadius,
		isFrontWheel, gWheelFriction, gRollInfluence);

	connectionPointCS0 = Ogre::Vector3(
		-CUBE_HALF_EXTENTS+(0.3*gWheelWidth),
		connectionHeight,
		2*CUBE_HALF_EXTENTS-gWheelRadius);


	mVehicle->addWheel(
		mWheelNodes[1],
		connectionPointCS0,
		wheelDirectionCS0,
		wheelAxleCS,
		gSuspensionRestLength,
		gWheelRadius,
		isFrontWheel, gWheelFriction, gRollInfluence);


	connectionPointCS0 = Ogre::Vector3(
		-CUBE_HALF_EXTENTS+(0.3*gWheelWidth),
		connectionHeight,
		-2*CUBE_HALF_EXTENTS+gWheelRadius);

	isFrontWheel = false;
	mVehicle->addWheel(
		mWheelNodes[2],
		connectionPointCS0,
		wheelDirectionCS0,
		wheelAxleCS,
		gSuspensionRestLength,
		gWheelRadius,
		isFrontWheel, gWheelFriction, gRollInfluence);

	connectionPointCS0 = Ogre::Vector3(
		CUBE_HALF_EXTENTS-(0.3*gWheelWidth),
		connectionHeight,
		-2*CUBE_HALF_EXTENTS+gWheelRadius);

	mVehicle->addWheel(
		mWheelNodes[3],
		connectionPointCS0,
		wheelDirectionCS0,
		wheelAxleCS,
		gSuspensionRestLength,
		gWheelRadius,
		isFrontWheel, gWheelFriction, gRollInfluence);
	*/
	// delete all pointers
	delete vehicle;
	delete tManager;
	delete obs;
}

//-------------------------------------------------------------------------------------
bool AZBullet::frameRenderingQueued(const Ogre::FrameEvent& arg)
{
	if(!BaseApplication::frameRenderingQueued(arg))
	{
		return false;
	}

	Real elapsedTime = arg.timeSinceLastFrame;
	
	mBulletWorld->stepSimulation(elapsedTime);

	return true;

}

// -------------------------------------------------------------------------
bool AZBullet::frameStarted(const FrameEvent& evt)
{
	Real elapsedTime = evt.timeSinceLastFrame;
	/*
	if(!OgreBulletListener::bulletFrameStarted(elapsedTime))
	{
		return false;
	}
	*/
	return true;
}

// -------------------------------------------------------------------------
bool AZBullet::frameEnded(const FrameEvent& evt)
{
	/*
	Real elapsedTime = evt.timeSinceLastFrame;
	if(!OgreBulletListener::bulletFrameEnded(elapsedTime))
	{
		return false;
	}
	*/
	return true; 
}


#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
#define WIN32_LEAN_AND_MEAN
#include "windows.h"
#endif

#ifdef __cplusplus
extern "C" {
#endif

#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
    // INT WINAPI WinMain( HINSTANCE hInst, HINSTANCE, LPSTR strCmdLine, INT )
	int main()
#else
    int main(int argc, char *argv[])
#endif
    {
        // Create application object
        AZBullet app;

        try 
		{
            app.go();
        } 
		catch( Ogre::Exception& e ) 
		{
#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
            MessageBox( NULL, e.getFullDescription().c_str(), "An exception has occured!", MB_OK | MB_ICONERROR | MB_TASKMODAL);
#else
            std::cerr << "An exception has occured: " <<
                e.getFullDescription().c_str() << std::endl;
#endif
        }

        return 0;
    }

#ifdef __cplusplus
}
#endif
